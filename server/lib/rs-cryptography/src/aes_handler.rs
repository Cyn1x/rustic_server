use std::fs::File;
use std::io::{Read, Write};

use rand::Rng;
use openssl::symm::{Cipher, encrypt_aead, decrypt_aead};

use crate::rand_handler;

/// The components required for AES 256-bit GCM encryption
pub struct AES {
    cipher: Cipher,
    key: Vec<u8>,
    iv: Vec<u8>,
    aad: Vec<u8>,
    tag: Vec<u8>,
}

impl AES {
    /// Returns a structure that allows encryption and decryption of data.
    ///
    /// # Arguments
    ///
    /// * `cipher`      - Represents a particular cipher algorithm
    /// * `key`         - The key used to encrypt the data
    /// * `iv`          - Contains the initialisation vector
    /// * `aand`        - Additional authenticated data
    /// * `tag`         - Tag generated by the encryption, used for decryption
    ///
    /// # Example
    ///
    /// ```
    /// // Example structure instantiation.
    /// use rs_cryptography::aes_handler;
    /// let mut aes_handler = aes_handler::AES::new();
    ///
    /// // Encrypt a file
    /// aes_handler.encrypt_file("path/to/file");
    ///
    /// // Decrypt a file
    /// let decrypted_data: String = aes_handler.decrypt_file("path/to/file");
    ///
    /// // Encrypt a buffer
    /// let arbitrary_buffer: &[u8] = b"Super secret data";
    /// let encrypted_buffer: Vec<u8> = aes_handler.encrypt_data(&arbitrary_buffer);
    /// ```
    pub fn new() -> AES {
        let cipher: Cipher = Cipher::aes_256_gcm();
        let key: Vec<u8>= rand_handler::generate_sequence(32);
        let iv: Vec<u8> = rand_handler::generate_sequence(64);
        let arbitrary_size: usize = rand::thread_rng().gen_range(0, 256);
        let aad: Vec<u8> = rand_handler::generate_sequence(arbitrary_size);
        let tag: Vec<u8> = rand_handler::generate_sequence(16);

        AES {
            cipher,
            key,
            iv,
            aad,
            tag
        }
    }

    /// Used to encrypt files. The encrypted file is stored in the server/var directory. The file
    /// that was encrypted is left in the server/var directory only for demonstration purposes.
    pub fn encrypt_file(&mut self, file: &str) {
        let mut file: File = File::open(file).expect("File not found.");
        let mut contents: String = String::new();

        file.read_to_string(&mut contents)
            .expect("Error streaming file contents to String buffer.");

        let encrypted_bytes: Vec<u8> = self.encrypt_data(
            contents.as_bytes());

        let mut encrypted_file: File = File::create(
            "server/var/encrypted_words.txt").expect("Unable to create file.");

        encrypted_file.write_all(&encrypted_bytes).expect("Unable to write to file.");
    }

    /// Used to decrypt files. The decrypted file is stored in the server/var directory. The file
    /// that was decrypted is returned as a String to the caller.
    pub fn decrypt_file(&self, filepath: &str) -> String {
        let mut decrypted_file: File = File::open(filepath).expect("File not found.");
        let mut file_contents: Vec<u8> = Vec::new();

        decrypted_file.read_to_end(&mut file_contents)
            .expect("Error streaming file contents to String buffer.");

        let decrypted_bytes: Vec<u8> = self.decrypt_data(&file_contents);

        String::from_utf8_lossy(&decrypted_bytes[..]).parse().unwrap()
    }

    /// Used to encrypt buffers. The tag is currently compulsory to use, as the `encrypt_aead`
    /// function stores the tag in `&mut self.tag` for later use. Returns a new buffer with
    /// encrypted bytes.
    pub fn encrypt_data(&mut self, buffer: &[u8]) -> Vec<u8> {
        let data: &[u8] = buffer;
        let ciphertext: Vec<u8> = encrypt_aead(
            self.cipher,
            &self.key,
            Some(&self.iv),
            &self.aad,
            data,
            &mut self.tag
        ).expect("Unable to encrypt ciphertext.");

        ciphertext
    }

    /// Used to decrypt buffers. The tag that was constructed in the `encrypt_data` function is
    /// used to decrypt the buffer. Returns a new buffer with decrypted bytes.
    pub fn decrypt_data(&self, buffer: &[u8]) -> Vec<u8> {
        let data: &[u8] = buffer;
        let ciphertext: Vec<u8> = decrypt_aead(
            self.cipher,
            &self.key,
            Some(&self.iv),
            &self.aad,
            data,
            &self.tag
        ).expect("Unable to decrypt ciphertext.");

        ciphertext
    }

}
